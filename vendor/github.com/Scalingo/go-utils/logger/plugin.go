package logger

import (
	"sync"

	"github.com/sirupsen/logrus"
)

var plugins = &PluginManager{}

// Plugins is the entrypoint to the global PluginManager
func Plugins() *PluginManager {
	return plugins
}

// Plugin is the interface that a Plugin need to implement to be compatible with the logger library
type Plugin interface {
	Name() string              // Return the name of the plugin. This name must be unique for each plugin
	Hook() (bool, logrus.Hook) // Return a boolean and a hook. If the boolean is set to true, the hook will be added to the logger, otherwise the hook will be ignored
}

type PluginManager struct {
	plugins []Plugin
	lock    sync.Mutex
}

// RegisterPlugin add a plugin to the current plugin list, if the plugin is already in memory, he will skip the add part
func (m *PluginManager) RegisterPlugin(plugin Plugin) {
	m.lock.Lock()
	defer m.lock.Unlock()

	for _, p := range m.plugins {
		if p.Name() == plugin.Name() {
			return
		}
	}

	m.plugins = append(m.plugins, plugin)
}

// Hooks return all the hooks generated by the plugins
func (m *PluginManager) Hooks() []logrus.Hook {
	m.lock.Lock()
	defer m.lock.Unlock()

	hooks := []logrus.Hook{}

	for _, plugin := range m.plugins {
		add, hook := plugin.Hook()
		if add {
			hooks = append(hooks, hook)
		}
	}

	return hooks
}
